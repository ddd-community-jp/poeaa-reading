# 第2章　ドメインロジック

## タイムテーブル

| 時間 | 所要時間 | 内容 |備考 |
| --------  | -------- | -------- | -------- |
| 20:00-20:15  | 15分   | 感想記入&HackMDに書かれた皆さんの感想・気づき・疑問をもっと掘り下げたいものを、 :+1: 付けていく  |      |
| 20:15-21:55   | 100分  | 本の節ごとにディスカッション（ここでも適宜、HackMDに気づきとか書いていってもらっていいです）     |    |
|21:55-22:00 | 5分 | 次回開催日と読む範囲決めてクローズ | |

---

## 概要

ドメインロジックの構築は3つのパターンに分類できる

|| 概要 | ProsCons |
|----|----|----|
| トランザクションスクリプト | ビジネスロジックを一連の手続きで構成する<br>処理は手続きに集中している<br>1つのエンティティに関連する処理は各トランザクションスクリプトに分散している | シンプルに記述できる<br>ビジネスロジック相互の干渉は発生しにくい<br>エンティティ毎、テーブル毎に処理を切り分けないので重複が発生しやすい |
| ドメインモデル | データベースの行に対応するエンティティに処理を記述する<br>ビジネスロジックはエンティティを渡り歩くように実行する<br>1つのビジネスロジックに対して記述は分散している | エンティティに関連する処理はエンティティに集中するので重複が発生しにくい<br>継承による処理の振り分けに対応しやすい<br>ビジネスロジック相互の干渉に注意が必要 |
| テーブルモジュール | データベーステーブルに対応するクラスに処理を記述する<br>ビジネスロジックはテーブルモジュールを渡り歩くように実行する<br>1つのビジネスロジックに対して記述は分散している | テーブルに関連する処理はテーブルモジュールに集中するので重複が発生しにくい<br>継承によってエンティティ毎に処理を振り分けることはできない<br>ビジネスロジック相互の干渉に注意が必要<br>行内の処理は記述しにくい<br>行のコレクションの処理は記述しやすい |

### トランザクションスクリプト

トランザクションスクリプトは、最もシンプルな手法で、プレゼンテーションからの入力を取得する手段を提供する。

トランザクションスクリプトは以下の手順で処理を実現する

1. 妥当性確認と計算によって入力を処理
1. データベースにデータを格納
1. 他のシステムの操作を呼び出す
1. 多くのデータを使ってプレゼンテーションに応答する

また、トランザクションスクリプトは、複数のサブルーチンから構成されている。しかし、パターンは各アクション毎の手続きを起動する必要がある。

トランザクションスクリプトには次のメリットがある

- シンプルな手続き型モデルで、容易に理解できる
- シンプルなデータソースレイヤと適切に連携する
	- 行データゲートウェイやテーブルデータゲートウェイを使用する
- トランザクションの境界が明確である
	- トランザクションのオープンが開始で、クローズが終了である
	- ツールを別途使用することで、バッググラウンド処理が容易に実現できる

一方、デメリットとしては次のものがある

- 複数のトランザクションが同じ処理をする必要があるため、コードが重複しやすい
	- 重複箇所を見つけ出すことも抽出することも困難である
- 明確な構造を持たない事が多い
	- ルーチンが絡まりあった状態になりやすい

### ドメインモデル

オブジェクト指向では、複雑なロジックに対して**ドメインモデル**で対処する。

ドメインモデルでは、概要レベルでドメイン内の名詞について体系化したモデルを構築する。ドメインモデルでは、妥当性確認や計算さんのためのロジックはドメインモデルに配置される。

>名詞について体系化した処理毎にモデルを作成する。対象の名詞に依存する手続きは該当のドメインモデルのメソッドに委譲される。つまり、オブジェクト指向のメリットを享受することが出来る。

ドメインモデルを使用することで、オブジェクト指向のパラダイムシフトを実現することができる

>1つのルーチンがユーザーアクションのすべてを持つ構造化プログラミングから、各オブジェクトが自身に関連するロジックを管理する

オブジェクト指向を採用することで、振る舞いを1箇所にまとめることが出来るが、実装方法を見つけることが難しいこともある。

ドメインモデルのコストは次の要素で決定する

- 対象のオブジェクトを使用するときの複雑性
- データソースレイヤの複雑性

つまり、ドメインモデルがリッチになるにつれてリレーショナルデータベースへのマッピングが複雑になる

### トランザクションスクリプトとドメインモデルの比較

トランザクションスクリプトとドメインモデルの違いを明確にするため、2つの処理のシーケンス図を以下に示す

| トランザクションスクリプト | ドメインモデル |
|:----:|:----:|
| ![トランザクションスクリプト](https://i.imgur.com/1JDezay.gif) | ![ドメインモデル](https://i.imgur.com/bVL1DaR.gif) |

2つのモデルの違いは「**誰が計算アルゴリズムを管理しているか**」である。

トランザクションスクリプトは、該当するメソッドが全てを管理する。基礎となるDataGatewayからデータを受け取り、該当するアルゴリズムを適用する。

一方、ドメインモデルでは、Productオブジェクトが管理をしている。つまり、振る舞いの一部をオブジェクトに委譲している。

もし、製品または計算アルゴリズムを追加する場合、トランザクションスクリプトは、スクリプトの条件分岐を追加することでアルゴリズムを追加する。一方、ドメインモデルでは、作成するオブジェクトを変更することでアルゴリズムを追加できる。

>インターフェースが共通のオブジェクトの追加であれば、オブジェクトの選択部分の修正だけでContractオブジェクトの修正が収束する可能性がある

### テーブルモジュール

>個人的にはテーブルモジュールパターンはRepositoryパターンだと思っている

テーブルモジュールとドメインモデルは、どちらも同じオブジェクトを持っている。

下図からもわかるように、テーブルモジュールはドメインモデルとトランザクションスクリプトの中間に位置するモデルである。

| テーブルモジュール | ドメインモデル |
|:----:|:----:|
| ![テーブルモジュール](https://i.imgur.com/guO3BEh.gif) | ![ドメインモデル](https://i.imgur.com/bVL1DaR.gif) |

2つのモデルの違いはContractのオブジェクトの数である。ドメインモデルでは、契約毎にContractオブジェクトが存在する。テーブルモジュールでは、1つしか存在しない。これによって、データと振る舞いを1つのパッケージに格納することが出来る。

テーブルモジュールはレコードセットに対応するように設計・実装されている。

1. Contractのクライアント(テーブルモジュール)は、データベースに最初のクエリーを発行し、レコードセットを作成する
1. Contractオブジェクトを作成する
1. クライアントはContractオブジェクトに対してレコードセットを引数として渡す
	- Contractオブジェクトを介して必要なアルゴリズムを呼び出す
	- 処理はIDを渡すことで変更する

テーブルモジュールの最大のメリットは、「**他のアーキテクチャにうまく適合すること**」である。多くのGUIアプリケーションは、レコードセットにまとめられたSQLクエリーの結果に従って動作するように構築されている。

- テーブルモジュールはレコードセット上で動作するので処理が簡単に実現できる
	- クエリーの実行
	- テーブルモジュールの結果の操作
	- 表示用の操作データのGUIへの送信
- 妥当性確認と計算処理もテーブルモジュールで実現できる

### 感想・気づき

- ロジックの実現方法が明確に分類されていて、頭の中が整理できてよかった
- ファウラーのドメインとエヴァンスのドメインで差がありそう
    - エヴァンスのドメインはファウラーのドメインよりも広い意味かな
- 「テーブルモジュール」あまり聞き馴染みがなかったが、[Martin Fowler's Bliki](https://bliki-ja.github.io/pofeaa/TableModule/)も参照するとより具体的にイメージできた
- この本が書かれた頃と比べるとUIで求められる操作も複雑になっているため、ドメインモデルを適用した際のデータソースレイヤ・プレゼンテーションレイヤの複雑性はより増していると感じた

### 疑問

## 選択

3つのパターンの選択は、ドメインロジックの複雑さによって左右される

![](https://i.imgur.com/zCkigt0.gif)

自身のアプリケーションがどこに位置するか見極める事が重要である。

また、複雑性以外の要因としては次のものがある

- プロジェクトチームのドメインモデルに対する習熟度
	- 習熟度の高いチームでは、ドメインモデルでも低コストでドメインモデルを構築することが出来る
- 共通のレコードセット構造を環境がサポートしているか
	- レコードセット用の特別なツールがなければテーブルモジュールの魅力は無い
	- .Net、Visual Studioなどの開発環境が該当する

最初にどのパターンを選択するかが重要なポイントになるが、決定を間違えていると気付いた時には、ためらわずにその決定を変更するべきである。

>ただし、拡張性が向上する方向のみの変更で、逆方向の変更は旨みがない

また、3つのパターンは排他的な選択肢ではなく、共存することが出来る。そのため、システムの各モジュール毎にパターンを選択する場合もある。

### 感想・気づき

- どの実現方法も否定はしていないのは好感
    - たしかに簡単な処理までドメインモデルで書くことはないかな
- オブジェクト志向のパラダイムシフトを経験していないと、トランザクションスクリプトでキツくなっていても決定が間違っていることに気づけないのが１番の問題だと感じた
- CAのユースケース層はトランザクションスクリプトとして実装しているなと感じた
    - と思ったけど、この定義だとドメインオブジェクトに処理を委譲しているのでトランザクションスクリプトとは違うかも？（本質的には委譲しているわけではないが、完成形の見え方は同形に近いと思う）
- :memo: Active Record Patternはテーブルモジュールなのでは？

### 疑問

- オブジェクト指向と手続き型の実装はイメージできているが、関数型だとどうなるんだろうか?
    - 関数型は本腰を入れてやったことがないので、手続き型に近いイメージを勝手に持っている
    - :memo: Unixのパイプに近い考えのもの
    - 関数型とは
        - 入力と出力がある
        - 関数が合成できる
            - 状態を持たない
            - 配管を組み合わせてくイメージ

## サービスレイヤ

ドメインロジックは複数のドメインレイヤに分割することが出来る。このレイヤのことをサービスレイヤと呼び、ドメインモデルまたはテーブルモジュールで使用される

>トランザクションスクリプトは、簡単な問題を扱うため、わざわざ分割するメリットがない

プレゼンテーションロジックは、アプリケーションのAPIの役割を果たすサービスレイヤを介してドメインにアクセスする

サービスレイヤは次の機能を実現する

- 明確なAPIの提供
- トランザクションの制御
- セキュリティの確保

サービスレイヤをどの程度充実させるかはサービスレイヤで実現したい特性によって変えるべきである

1. 最小限の機能の実装
	- ファサードを利用し、振る舞いの全てを下位オブジェクトに移譲する
	- サービスレイヤがユースケースの中心になるので、使いやすいAPIを提供できる
	- トランザクションラッパーとセキュリティチェックを実現しやすい構造である
1. 中間的な実装
	- コントローラ-エンティティという振る舞いの組み合わせ
		- 共通のプラクティスが由来する
	- コントローラまたはサービスと呼ばれる機能(ユースケースコントローラ)を実装する
		- **トランザクションスクリプト内に配置される1つのトランザクションはユースケースに特有のロジックを持つ**
		- MACモデルやアプリケーションコントローラなどの入力コントローラとは別の機能を提供する
	- 複数のユースケースで利用される振る舞いは、ドメインモデルに移り、エンティティと呼ばれる
1. 多くのビジネスロジックを実装
	- サービスレイヤ内のトランザクションスクリプトで多くの機能を実現する
		- 下位のオブジェクトがシンプルになる
	- ドメインモデルであれば、データベースと1対1の関係になる
		- アクティブレコードの利用
		- シンプルなデータソースレイヤの利用

サービスレイヤの実装の充実は設計者によって見解が異なる。

### 感想・気づき

- ここも「どの選択肢を選ぶかはプロダクトの特性次第」と言っていることに好感
    - 個人的にはウェブ記事などこの部分の扱いが違和感を感じ始めた
    - 究極の「最小限の機能の実装」はLinuxじゃないか?
        - Unix思想：一つのことをうまくやる
        - 集約境界をうまく扱う
- サービスレイヤを厚くするとドメイン知識が漏れ出てしまうのは納得した
    - 大量のロジックともにサービスレイヤを使用する優れた設計というのがあまりイメージできなかった
        - :memo: これこそが関数型で実装するということなのでは？
            - 関数→状態を持たない、合成可能な、（一つのことをうまくやれる単位に分解された）ロジック

### 疑問
----

## 放課後

###### tags: `PoEAA`