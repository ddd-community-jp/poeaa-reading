# 第1章　レイヤ化

## 概要

レイヤ化は、**複雑なソフトウェアのシステムを分割統治するために使用される技法**である。

レイヤには次の特徴がある

- サブシステムを、レイヤの積み重なったものとして捉えることができる
- 各レイヤはその下のレイヤに依存する
	- 上位のレイヤは下位のレイヤで定義された様々なサービスを使用できる
	- 下位のレイヤは上位のレイヤを意識しない(ことが多い)
	    - > レイヤ化アーキテクチャのレイヤすべてがこのように互いに不透明なわけではないが、多くは不透明である
- 各レイヤは隣接するレイヤのみを使用する

>個人的に一番綺麗なレイヤードアーキテクチャは[OSI参照モデル](https://www.cisco.com/c/m/ja_jp/primer/osi-reference-model.html)かと思います

| OSI参照モデルと各層の責務 |
|:----:|
|<img src="https://www.infraexpert.com/studygif/networking14.gif" width=500>|

レイヤ間の依存関係を少なくすることで管理を容易する。しかし、レイヤ間の依存関係を最小にするためにパフォーマンスを犠牲にしたり、下位のレイヤの変更が上位レイヤへと連鎖する場合がある

レイヤ化で最も難しいのは、**必要なレイヤと、各レイヤが行う内容を決定すること**である

## エンタープライズアプリケーションのレイヤの発展

レイヤ概念が発展するまで
1. ファイル操作プログラム = アプリケーションであり、レイヤは必要なかった
2. クライアント/サーバシステムという2レイヤシステムの発展による、レイヤ概念の明確化
3. Webの登場を契機とした3レイヤの流行
    - オブジェクトコミュニティから登場
    - プレゼンテーション/ドメインロジック/データソースの3層
    - 登場はクライアント/サーバシステムと同時期だが、当時は主流にならなかった

レイヤとティアは同義語として扱われることが多いが、明確な違いがある

| 用語 | 定義 |
|---|---|
| レイヤ | 物理的な区別はなく、概念的な区別<br>1つのマシン内で別々の役割を持たせる |
| ティア | 物理的に区別できるもの<br>例: クライアントマシンとサーバーマシン |

レイヤの数とマシンの数は必ずしも一致しない
- 例
    - 2ノード3レイヤ
    - ローカルマシン上で3レイヤ全てを実行(1ノード3レイヤ)

### 感想・気づき

- 昔から分散・オブジェクト指向での整理が行われてきたんだな
- 今はオブジェクト指向がうまく適用できていないことによる複雑さの課題が出ているんじゃないかな
- ビジネスルールが複雑になるに連れて、ドメインロジックの置き場がUI画面・DBのどちらにも置くことができなくなった

### 疑問
- >実際にデータベースベンダーを変更する人はほとんどいないのに、なぜか多くの人は移植に高いコストをかけずにベンダーを変更できる選択肢を持ちたがるのだ
    - 現在においてもこの傾向はあるのかどうか？
    - 自動テストなどでDB接続をモック化する場合、「頻繁にデータベース実装が（オンメモリという有る種のベンダに）変更される」とも言えるのでは説
    - DBベンダを変更する可能性がゼロであっても、DBの設定変更やSQLチューニングの結果を伝播させにくい、あるいは伝播させずに済む*可能性がある*、という点には価値を感じる。
- 3レイヤについての解説とオブジェクト指向についての解説が、ごっちゃになっている感じがする
    - 言いたいことは、だいたい（多分）わかるのだけれど
    - ↓は3レイヤが主流にならなかった理由であって、 "オブジェクト指向は主流にならなかった"理由ではなさそうな（少なくとも、本文の解説内容では）
        - 「オブジェクト指向コミュニティから3レイヤが提示されたが、当時のシステムはまだ（少なくとも開発時には）シンプルで、3レイヤを導入するほどのものではなかった」
        - 「オブジェクト指向コミュニティから3レイヤが提示されたが、それは当時主流のクラサバ構成には適用させづらかった」
        - 「↑の理由で3レイヤは敬遠されたが、それが提示される土壌となったオブジェクト指向も一緒くたに敬遠された」みたいな話なら、本文の語り口もわからないでもない

## 3つの主なレイヤ

| レイヤ化 |
|:----:|
|<img src="https://i.imgur.com/OVlx74k.png" width=500>|

| 用語 | 定義 |
|---|---|
| プレゼンテーションレイヤ | ユーザとソフトウェアの相互作用を扱う<br>ユーザーに情報を表示したり、ユーザーからのコマンドをドメインやデータソースでの動作に変換したりするようなコードが該当する |
| ドメインレイヤ | システムを特徴付けるロジックを置くレイヤで、ビジネスロジックとも呼ばれる<br>入力データや格納データに基づく計算や、入力データの妥当性検証、また状況に応じたデータソースの選択などが該当する |
| データソースレイヤ | 他のシステムとの通信を行い、アプリケーションのためにタスクを実行する |

- 必ずしもこの3レイヤに分けるとは限らない。状況に応じて最も適切な分割の仕方を選択する。ただし最低限サブルーチンレベルの分割は行ったほうが良い。
- ドメインとデータソースはプレゼンテーションに依存してはいけない。
- 何がドメインロジックで何がそれ以外かを見極めるのは難しい。まったく異なるレイヤを追加したり、全くことなる実装に置き換えたりする場合を想像してみるのが、Fowlerのお気に入り。

※本書で「リッチクライアント」という場合、それはHTMLブラウザーではなく、WindowsやSwingなどのファットクライアントのUIを意味する

### 感想・気づき
- > 他へのサービスとして提供するインタフェースと、他のサービスを使用することとの間には、歴然とした違いがあるからだ。
    - この非対称性への言及は同意。
        - 文脈が変わるので、観点も変わるだろうという点から、この非対称性を意識可能にしたい感
    - 一方で、CAの「中心へ向けた依存の一方向化」という視点や、ヘキサゴナルの「外部との接続可能性」といった観点も、捨てがたいものが個人的にある
    - 非対称性は維持しつつ、上記のような観点を組み込むことができると、また面白いものができそうな気がする
    - 依存の方向については特に言及されていないような気がしていて、ヘキサゴナルアーキテクチャに対しては「インターフェイス」として同じ層に置くことに対する指摘なのではと感じた
        - 個人的にはCAもヘキサゴナルもレイヤードアーキテクチャの一種という認識
- 非対称性を表現しているためにレイヤードアーキテクチャにしているのは面白い
- オニオンアーキテクチャやCAのようにドメインが中心に来ると、ドメイン層に特別感がでることが違和感があることは同意
    - この2つのアーキテクチャも`ドメイン層を守ること`が目的ではなく、分割統治が目的だと思う
    - 特別感が出ることで勘違いする人や不適切な設計が発生する気がする
- これをうまく実現するためにはアラン・ケイのオブジェクト指向なのかな
    - レイヤの実現可能性や容易性は、スラウストラップのOOでも（クラス指向、抽象データ型指向）ラッセルのOOでも（I/F指向）、それほど変わりなさそうな
    - レイヤ同士の接合点をどのように見るかで、各人の思想の特徴がでそうかも？
        - アラン・ケイ -> メッセージの交換地点？
        - スラウストラップ -> 抽象データの変換地点？
        - メイヤー -> 契約の境界？
- > ドメインとデータソースの関係はより複雑で、データソースのアーキテクチャパターンによって異なる
    - ヘキサゴナルやCAのように外部レイヤを対称性をもって扱うアーキテクチャを採用する際も上記を意識することは重要であると感じた。
    - データソースレイヤにあたる外部システムの採用はかなり慎重に選択する必要性を感じたのでCAではそのことをあまり触れていないが、意識することが必要だと感じた。
- > 私が好きな非公式のテストは、Webアプリケーションにコマンドラインインタフェースを追加するときのように、まったく異なるレイヤをアプリケーションに追加することを想像するというものである。(...)同様に、リレーショナルデータベースをXMLファイルで置き換えるために、ロジックを複製する必要があるかどうか考えてみるとよい。
    - よくやる。例えば「S3に保存して」と言われたら、とりあえずDB経由のケースと外部サービス経由のケースは考えてみてる。
- データソースがアプリケーションの本尊（データ中心設計？）、という考え方が主流だったのかな、という感想
    - CAは、データソースじゃないところにドメインの本質がある、と考えて、アーキテクチャにも依存関係逆転の原則を当てはめたんだと思っている

### 疑問

## レイヤの実行場所の選択

責務の割当によるメリット/デメリットを比較して、設計対象のアプリケーションで優先するべき特徴をもたらしてくれるレイヤ配置が重要になる。

どのようなレイヤ配置をする場合でも守るべきルールとして、「**レイヤを別々のプロセスに分割してはならない**」がある。別々のプロセスに分割するとパフォーマンスは悪化する傾向があり、複雑性も大きくなる傾向がある。

このような問題を**複雑性のブースター**と呼ぶ。以下のような実装は気を付けるべきである

- 分散処理
- 明示的なマルチスレッド化
- パラダイムの食い違い
	- オブジェクトかリレーショナルかなど
- マルチプラットフォームの開発
- 極めて高いパフォーマンス要求

### 感想・気づき

- ここが自分の抱いていたモヤモヤの部分の回答なのでスッキリした

### 疑問
- > 多くのISアプリケーション
    - Information System Application の略という理解で良いのだろうか……（初見）
    - IS部門という言葉が出てくるの見ると、 IS = Information System で良さげ？

----

## 放課後

###### tags: `PoEAA`